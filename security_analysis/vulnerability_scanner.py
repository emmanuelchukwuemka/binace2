"""
Advanced Vulnerability Scanner
Specialized scanner for specific attack vectors and vulnerabilities
"""

import asyncio
import json
import hashlib
import re
from typing import Dict, List, Any, Set
from dataclasses import dataclass
from web3 import Web3
import requests
import logging

logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Specific vulnerability finding"""
    name: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    description: str
    attack_vector: str
    mitigation: str
    references: List[str]
    affected_assets: List[str]

class AdvancedVulnerabilityScanner:
    """Advanced vulnerability scanner for Ethereum addresses"""
    
    def __init__(self, rpc_endpoint: str = "https://ethereum-rpc.publicnode.com"):
        self.w3 = Web3(Web3.HTTPProvider(rpc_endpoint))
        self.vulnerabilities = []
        
    def scan_private_key_exposure(self, address: str) -> List[Vulnerability]:
        """Scan for potential private key exposure patterns"""
        vulnerabilities = []
        
        # Check for common weak private key patterns
        weak_patterns = [
            "0x0000000000000000000000000000000000000000000000000000000000000001",
            "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        ]
        
        # This is theoretical - we can't actually check private keys
        # But we can warn about weak key generation
        vulnerabilities.append(Vulnerability(
            name="Private Key Security",
            severity="HIGH",
            description="Private key security cannot be verified externally",
            attack_vector="Weak random number generation, predictable keys",
            mitigation="Use hardware wallets or secure random generation",
            references=["https://ethereum.org/en/security/"],
            affected_assets=[address]
        ))
        
        return vulnerabilities
    
    def scan_replay_attacks(self, address: str) -> List[Vulnerability]:
        """Scan for replay attack vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check chain ID usage in recent transactions
            transactions = self.get_recent_transactions(address, 10)
            
            old_transactions = []
            for tx in transactions:
                # Check if transaction was made before EIP-155 (chain ID)
                tx_hash = tx.get('hash')
                if tx_hash:
                    try:
                        tx_details = self.w3.eth.get_transaction(tx_hash)
                        if not hasattr(tx_details, 'chainId') or tx_details.chainId is None:
                            old_transactions.append(tx_hash)
                    except:
                        continue
            
            if old_transactions:
                vulnerabilities.append(Vulnerability(
                    name="Replay Attack Vulnerability",
                    severity="MEDIUM",
                    description="Transactions without chain ID protection detected",
                    attack_vector="Transaction replay across different networks",
                    mitigation="Use EIP-155 compliant transactions with chain ID",
                    references=["https://eips.ethereum.org/EIPS/eip-155"],
                    affected_assets=old_transactions
                ))
                
        except Exception as e:
            logger.warning(f"Replay attack scan failed: {e}")
        
        return vulnerabilities
    
    def scan_front_running_exposure(self, address: str) -> List[Vulnerability]:
        """Scan for front-running vulnerabilities"""
        vulnerabilities = []
        
        try:
            transactions = self.get_recent_transactions(address, 50)
            
            # Analyze gas price patterns
            gas_prices = []
            for tx in transactions:
                if 'gasPrice' in tx:
                    gas_prices.append(int(tx['gasPrice']))
            
            if len(gas_prices) >= 5:
                avg_gas = sum(gas_prices) / len(gas_prices)
                low_gas_count = len([gp for gp in gas_prices if gp < avg_gas * 0.8])
                
                if low_gas_count > len(gas_prices) * 0.3:  # >30% low gas transactions
                    vulnerabilities.append(Vulnerability(
                        name="Front-Running Exposure",
                        severity="MEDIUM",
                        description="Frequent use of low gas prices increases front-running risk",
                        attack_vector="MEV bots can front-run low gas price transactions",
                        mitigation="Use appropriate gas prices and consider private mempools",
                        references=["https://ethereum.org/en/developers/docs/mev/"],
                        affected_assets=[address]
                    ))
            
            # Check for predictable transaction timing
            timestamps = [int(tx['timeStamp']) for tx in transactions if 'timeStamp' in tx]
            if len(timestamps) >= 10:
                time_diffs = [timestamps[i] - timestamps[i+1] for i in range(len(timestamps)-1)]
                regular_intervals = len([diff for diff in time_diffs if abs(diff - 3600) < 300])  # ~1 hour intervals
                
                if regular_intervals > 3:
                    vulnerabilities.append(Vulnerability(
                        name="Predictable Transaction Timing",
                        severity="LOW",
                        description="Regular transaction timing patterns detected",
                        attack_vector="Predictable timing allows for targeted attacks",
                        mitigation="Randomize transaction timing",
                        references=["https://consensys.github.io/smart-contract-best-practices/"],
                        affected_assets=[address]
                    ))
                    
        except Exception as e:
            logger.warning(f"Front-running scan failed: {e}")
        
        return vulnerabilities
    
    def scan_address_reuse(self, address: str) -> List[Vulnerability]:
        """Scan for address reuse patterns"""
        vulnerabilities = []
        
        try:
            transactions = self.get_recent_transactions(address, 100)
            
            # Count unique counterparties
            counterparties = set()
            for tx in transactions:
                if tx['from'].lower() == address.lower():
                    counterparties.add(tx['to'].lower())
                else:
                    counterparties.add(tx['from'].lower())
            
            # High reuse with same addresses
            if len(transactions) > 20 and len(counterparties) < 5:
                vulnerabilities.append(Vulnerability(
                    name="Address Reuse Pattern",
                    severity="MEDIUM",
                    description="High transaction frequency with few unique addresses",
                    attack_vector="Pattern analysis and address linking",
                    mitigation="Use different addresses for different purposes",
                    references=["https://en.bitcoin.it/wiki/Address_reuse"],
                    affected_assets=[address]
                ))
            
            # Check for round-number patterns (potential automated behavior)
            values = []
            for tx in transactions:
                if tx['value'] != '0':
                    eth_value = float(Web3.from_wei(int(tx['value']), 'ether'))
                    values.append(eth_value)
            
            round_values = [v for v in values if v in [0.1, 0.5, 1.0, 5.0, 10.0, 50.0, 100.0]]
            if len(round_values) > len(values) * 0.5 and len(values) > 10:
                vulnerabilities.append(Vulnerability(
                    name="Automated Behavior Pattern",
                    severity="LOW",
                    description="High frequency of round-number transactions",
                    attack_vector="Behavioral analysis and pattern recognition",
                    mitigation="Vary transaction amounts and timing",
                    references=["https://en.wikipedia.org/wiki/Traffic_analysis"],
                    affected_assets=[address]
                ))
                
        except Exception as e:
            logger.warning(f"Address reuse scan failed: {e}")
        
        return vulnerabilities
    
    def scan_dust_attacks(self, address: str) -> List[Vulnerability]:
        """Scan for dust attack vulnerabilities"""
        vulnerabilities = []
        
        try:
            transactions = self.get_recent_transactions(address, 200)
            
            # Find very small incoming transactions
            dust_transactions = []
            for tx in transactions:
                if (tx['to'].lower() == address.lower() and 
                    tx['value'] != '0'):
                    eth_value = float(Web3.from_wei(int(tx['value']), 'ether'))
                    if 0 < eth_value < 0.0001:  # Very small amounts
                        dust_transactions.append(tx)
            
            if len(dust_transactions) > 5:
                vulnerabilities.append(Vulnerability(
                    name="Dust Attack Exposure",
                    severity="MEDIUM",
                    description="Multiple very small incoming transactions detected",
                    attack_vector="Privacy compromise through transaction graph analysis",
                    mitigation="Do not consolidate dust; use fresh addresses",
                    references=["https://academy.binance.com/en/articles/what-is-a-dusting-attack"],
                    affected_assets=[tx['hash'] for tx in dust_transactions[:5]]
                ))
                
        except Exception as e:
            logger.warning(f"Dust attack scan failed: {e}")
        
        return vulnerabilities
    
    def scan_reentrancy_risks(self, address: str) -> List[Vulnerability]:
        """Scan for reentrancy attack exposure"""
        vulnerabilities = []
        
        try:
            transactions = self.get_recent_transactions(address, 100)
            
            # Look for contract interactions
            contract_calls = []
            for tx in transactions:
                if tx.get('input', '0x') != '0x' and len(tx.get('input', '')) > 10:
                    contract_calls.append(tx)
            
            if contract_calls:
                # Check for external calls patterns
                external_call_patterns = []
                for tx in contract_calls:
                    input_data = tx.get('input', '')
                    # Look for common external call signatures
                    if any(sig in input_data for sig in ['a9059cbb', '23b872dd', '095ea7b3']):
                        external_call_patterns.append(tx['hash'])
                
                if external_call_patterns:
                    vulnerabilities.append(Vulnerability(
                        name="Reentrancy Risk Exposure",
                        severity="HIGH",
                        description="Interactions with contracts that make external calls",
                        attack_vector="Reentrancy attacks on vulnerable contracts",
                        mitigation="Use reentrancy guards and check contract security",
                        references=["https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"],
                        affected_assets=external_call_patterns[:3]
                    ))
                    
        except Exception as e:
            logger.warning(f"Reentrancy scan failed: {e}")
        
        return vulnerabilities
    
    def scan_phishing_exposure(self, address: str) -> List[Vulnerability]:
        """Scan for phishing attack exposure"""
        vulnerabilities = []
        
        try:
            transactions = self.get_recent_transactions(address, 50)
            
            # Look for suspicious approval transactions
            suspicious_approvals = []
            for tx in transactions:
                input_data = tx.get('input', '')
                # ERC20 approve function signature
                if input_data.startswith('0x095ea7b3'):
                    # Check if approval is for maximum amount (common phishing tactic)
                    if 'f' * 60 in input_data:  # Max uint256 contains many f's
                        suspicious_approvals.append(tx)
            
            if suspicious_approvals:
                vulnerabilities.append(Vulnerability(
                    name="Phishing Attack Exposure",
                    severity="HIGH",
                    description="Unlimited token approvals detected",
                    attack_vector="Malicious contracts can drain approved tokens",
                    mitigation="Revoke unnecessary approvals, use limited approvals",
                    references=["https://kalis.me/check-allowance/"],
                    affected_assets=[tx['hash'] for tx in suspicious_approvals[:3]]
                ))
            
            # Check for interactions with new/unverified contracts
            recent_contract_interactions = []
            for tx in transactions:
                if (tx.get('input', '0x') != '0x' and 
                    int(tx['timeStamp']) > (int(time.time()) - 30*24*3600)):  # Last 30 days
                    recent_contract_interactions.append(tx)
            
            if len(recent_contract_interactions) > 10:
                vulnerabilities.append(Vulnerability(
                    name="High Contract Interaction Risk",
                    severity="MEDIUM",
                    description="High frequency of recent contract interactions",
                    attack_vector="Exposure to unverified or malicious contracts",
                    mitigation="Verify contract security before interaction",
                    references=["https://ethereum.org/en/security/"],
                    affected_assets=[address]
                ))
                
        except Exception as e:
            logger.warning(f"Phishing scan failed: {e}")
        
        return vulnerabilities
    
    def get_recent_transactions(self, address: str, limit: int = 100) -> List[Dict]:
        """Get recent transactions for analysis"""
        try:
            etherscan_api = "https://api.etherscan.io/api"
            params = {
                'module': 'account',
                'action': 'txlist',
                'address': address,
                'startblock': 0,
                'endblock': 99999999,
                'page': 1,
                'offset': limit,
                'sort': 'desc'
            }
            
            response = requests.get(etherscan_api, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get('status') == '1':
                    return data.get('result', [])
            
            return []
            
        except Exception as e:
            logger.error(f"Transaction fetch failed: {e}")
            return []
    
    async def comprehensive_scan(self, address: str) -> List[Vulnerability]:
        """Perform comprehensive vulnerability scan"""
        all_vulnerabilities = []
        
        logger.info(f"Starting comprehensive vulnerability scan for {address}")
        
        # Run all vulnerability scans
        scan_functions = [
            self.scan_private_key_exposure,
            self.scan_replay_attacks,
            self.scan_front_running_exposure,
            self.scan_address_reuse,
            self.scan_dust_attacks,
            self.scan_reentrancy_risks,
            self.scan_phishing_exposure
        ]
        
        for scan_func in scan_functions:
            try:
                vulnerabilities = scan_func(address)
                all_vulnerabilities.extend(vulnerabilities)
                logger.info(f"Completed {scan_func.__name__}: {len(vulnerabilities)} issues found")
            except Exception as e:
                logger.error(f"Scan {scan_func.__name__} failed: {e}")
        
        return all_vulnerabilities
    
    def generate_vulnerability_report(self, vulnerabilities: List[Vulnerability], address: str) -> Dict:
        """Generate formatted vulnerability report"""
        # Categorize by severity
        critical = [v for v in vulnerabilities if v.severity == "CRITICAL"]
        high = [v for v in vulnerabilities if v.severity == "HIGH"]
        medium = [v for v in vulnerabilities if v.severity == "MEDIUM"]
        low = [v for v in vulnerabilities if v.severity == "LOW"]
        info = [v for v in vulnerabilities if v.severity == "INFO"]
        
        # Calculate risk score
        risk_score = (len(critical) * 100 + len(high) * 50 + 
                     len(medium) * 25 + len(low) * 10 + len(info) * 5)
        
        # Determine overall risk level
        if risk_score >= 200:
            overall_risk = "CRITICAL"
        elif risk_score >= 100:
            overall_risk = "HIGH"
        elif risk_score >= 50:
            overall_risk = "MEDIUM"
        else:
            overall_risk = "LOW"
        
        report = {
            "address": address,
            "scan_timestamp": datetime.now().isoformat(),
            "overall_risk_level": overall_risk,
            "risk_score": risk_score,
            "total_vulnerabilities": len(vulnerabilities),
            "severity_breakdown": {
                "critical": len(critical),
                "high": len(high),
                "medium": len(medium),
                "low": len(low),
                "info": len(info)
            },
            "vulnerabilities": [
                {
                    "name": v.name,
                    "severity": v.severity,
                    "description": v.description,
                    "attack_vector": v.attack_vector,
                    "mitigation": v.mitigation,
                    "references": v.references,
                    "affected_assets": v.affected_assets
                }
                for v in vulnerabilities
            ]
        }
        
        return report

async def main():
    """Run advanced vulnerability scan"""
    import time
    from datetime import datetime
    
    target_address = "0xB5c1baF2E532Bb749a6b2034860178A3558b6e58"
    
    print("🔍 Advanced Vulnerability Scanner")
    print("=" * 50)
    print(f"🎯 Target: {target_address}")
    print()
    
    scanner = AdvancedVulnerabilityScanner()
    
    try:
        # Perform comprehensive scan
        vulnerabilities = await scanner.comprehensive_scan(target_address)
        
        # Generate report
        report = scanner.generate_vulnerability_report(vulnerabilities, target_address)
        
        # Display results
        print(f"📊 VULNERABILITY SCAN RESULTS")
        print(f"⚠️ Overall Risk Level: {report['overall_risk_level']}")
        print(f"📈 Risk Score: {report['risk_score']}")
        print(f"🔍 Total Issues: {report['total_vulnerabilities']}")
        print()
        
        print("📊 Severity Breakdown:")
        breakdown = report['severity_breakdown']
        print(f"   🔴 Critical: {breakdown['critical']}")
        print(f"   🟠 High: {breakdown['high']}")
        print(f"   🟡 Medium: {breakdown['medium']}")
        print(f"   🔵 Low: {breakdown['low']}")
        print(f"   ℹ️ Info: {breakdown['info']}")
        print()
        
        if vulnerabilities:
            print("🚨 DETAILED VULNERABILITIES:")
            for i, vuln in enumerate(vulnerabilities, 1):
                print(f"{i}. [{vuln.severity}] {vuln.name}")
                print(f"   📝 {vuln.description}")
                print(f"   ⚔️ Attack Vector: {vuln.attack_vector}")
                print(f"   🛡️ Mitigation: {vuln.mitigation}")
                if vuln.affected_assets:
                    print(f"   📁 Affected: {', '.join(vuln.affected_assets[:2])}...")
                print()
        
        # Save report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"vulnerability_report_{target_address[:8]}_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"📄 Report saved to: {filename}")
        
    except Exception as e:
        print(f"❌ Scan failed: {e}")

if __name__ == "__main__":
    asyncio.run(main())